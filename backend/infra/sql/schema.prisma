generator kysely {
    provider            = "prisma-kysely"
    output              = "./kysely"
    fileName            = "types.ts"
    decimalTypeOverride = "number"
    jsonTypeOverride    = "Record<string,any>"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model LiteraryWork {
    id        BigInt                @id @default(dbgenerated("generate_tsid('LiteraryWork')"))
    names     Json                  @db.JsonB // {"alternative"?: string[], "english"?: string, "romanized"?: string, "original": string}
    synopsis  String?               @db.Text
    type      String                @db.VarChar(16)
    tags      String[]              @db.VarChar(30)
    ongoing   Boolean               @default(true) @db.Boolean
    chapters  LiteraryWorkChapter[]
    createdAt DateTime              @default(now())
    updatedAt DateTime              @default(now())
}

model LiteraryWorkChapter {
    id          BigInt        @id @default(dbgenerated("generate_tsid('LiteraryWorkChapter')"))
    title       Json?         @db.JsonB // {"english"?: string, "original"?: string}
    number      Int?          @db.SmallInt
    releaseDate DateTime?     @db.Date
    pages       Int?          @db.SmallInt
    readingTime Int?          @db.SmallInt
    sourceId    BigInt
    source      LiteraryWork  @relation(fields: [sourceId], references: [id], onDelete: Cascade)
    readBy      UserChapter[]
    createdAt   DateTime      @default(now())
    updatedAt   DateTime      @default(now())
}

model User {
    email         String        @id @db.VarChar(320)
    password      String        @db.VarChar(128)
    videosWatched UserVideo[]
    chaptersRead  UserChapter[]
    createdAt     DateTime      @default(now())
    updatedAt     DateTime      @default(now())
}

model UserChapter {
    email      String              @db.VarChar(320)
    user       User                @relation(fields: [email], references: [email], onDelete: Cascade)
    chapterId  BigInt
    chapter    LiteraryWorkChapter @relation(fields: [chapterId], references: [id], onDelete: Cascade)
    readAt     DateTime?           @db.Timestamptz
    timeSpent  Int?                @db.SmallInt
    bookmarked Boolean?            @db.Boolean

    @@id([email, chapterId])
}

model UserVideo {
    email      String    @db.VarChar(320)
    user       User      @relation(fields: [email], references: [email], onDelete: Cascade)
    videoId    BigInt
    video      Video     @relation(fields: [videoId], references: [id], onDelete: Cascade)
    when       DateTime? @db.Timestamptz
    watchTime  Int?      @db.Integer
    bookmarked Boolean?  @db.Boolean

    @@id([email, videoId])
}

model Video {
    id         BigInt         @id @default(dbgenerated("generate_tsid('Video')"))
    title      String         @db.Text
    link       String?        @db.Text
    duration   Int            @db.Integer
    channelId  BigInt
    channel    VideoChannel   @relation(fields: [channelId], references: [id], onDelete: Cascade)
    playlistId BigInt?
    playlist   VideoPlaylist? @relation(fields: [playlistId], references: [id])
    watchedBy  UserVideo[]
    createdAt  DateTime       @default(now())
    updatedAt  DateTime       @default(now())
}

model VideoChannel {
    id        BigInt          @id @default(dbgenerated("generate_tsid('VideoChannel')"))
    name      String          @db.Text
    link      String?         @db.Text
    videos    Video[]
    playlists VideoPlaylist[]
    createdAt DateTime        @default(now())
    updatedAt DateTime        @default(now())
}

model VideoPlaylist {
    id        BigInt        @id @default(dbgenerated("generate_tsid('VideoPlaylist')"))
    title     String        @db.Text
    link      String?       @db.Text
    videos    Video[]
    channelId BigInt?
    channel   VideoChannel? @relation(fields: [channelId], references: [id], onDelete: Cascade)
    createdAt DateTime      @default(now())
    updatedAt DateTime      @default(now())
}
